{\rtf1\ansi\ansicpg1252\cocoartf1038\cocoasubrtf360
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww9000\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\ql\qnatural\pardirnatural

\f0\fs24 \cf0 Notes to myself on Assignment 2:\
\
Assign2: our biggest problem. We must beat this into submission. But how?\
\
ILexicon: All our searches through the lexicon files will be thanks to this (in Lexicon.java). This will do brute force searches, but will not be too terribly difficult.\
\
Diller.txt (lowercase): We must make one for testing. Or make a bunch. That\'92d be nice.\
\
\pard\tx220\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\li720\fi-720\ql\qnatural\pardirnatural
\ls1\ilvl0\cf0 {\listtext	\'95	}For now, assume linear search. \
{\listtext	\'95	}Find word of right length. If yes, do next test; if not, try new word. \
{\listtext	\'95	}Check to see if word has only one letter difference. If yes, make note; if not, move on.\
{\listtext	\'95	}Potential: make an array of arrays, like a giant tree. Then we could check to see which one has the shortest length. // Or give it intelligence so that it can backtrack if it sees it can\'92t make a decent tree\
{\listtext	\'95	}Suggestion: Have WordA & Word0. Transpose Letter n to letter n. Check to see if a word. If yes, change. If no, move on to letter 1. Then so on. If no changes are possible, go to last and change to nearest letter that\'92s a word. So on and so forth.\
}